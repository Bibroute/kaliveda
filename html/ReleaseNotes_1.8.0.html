<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
  <meta content="text/html; charset=ISO-8859-1"
 http-equiv="Content-Type">
  <title>KaliVeda v1.8.0 Release Notes</title>
  <link rel="stylesheet" href="css/site.css" type="text/css">
</head>
<body>
<h1>KaliVeda v1.8.0 Release Notes</h1>
<div class="leftSide">
<div class="KaliVeda">KaliVeda</div>
<img
 style="margin-left: 1px; margin-top: 1px; width: 110px; height: 100px;"
 alt="indra" src="images/indra_camp4_210x188.png"><br>
<script language="javascript" src="js/nav.js"></script>
<br>
<!-- SiteSearch Google -->
<form method="get" action="http://www.google.com/search"><input
 name="ie" value="UTF-8" type="hidden"> <input name="oe" value="UTF-8"
 type="hidden"><input name="q" style="margin-top: 5px;" size="13"
 maxlength="255" value="" type="text"> <input name="btnG"
 style="margin-top: 5px;" value="Search site"
 onclick="send_data(this.form)" type="submit"></form>
<!-- SiteSearch Google -->
</div>
<div class="page">
<h2><br>
</h2>
Here is a list of some of the innovations in KaliVeda v1.8.0.<br>
For more details, see <a
 href="https://launchpad.net/kaliveda/+milestone/1.8.0">here</a>.<br>
<br>
<h2>Data format in ROOT files</h2>
<br>
Multidetector array objects are no longer written in ROOT files along
with TTree containing data. This means that reconstructed data files
written with versions &lt;1.8 cannot be read with versions &gt;=1.8,
and vice versa. See this <a
 href="http://indra.in2p3.fr/spip2/IMG/pdf/John_kaliveda_1-8_juin2010.pdf">presentation</a>
for details (en fran&ccedil;ais).<br>
<br>
<h2>Regeneration of INDRA data (campaigns 1-4)</h2>
<br>
The DST-&gt;ROOT conversion now appears as a data analysis task in the
KaliVedaGUI. Most of the necessary corrections have been applied to the
old data. See this <a
 href="http://indra.in2p3.fr/spip2/IMG/pdf/KaliVeda_Dst.pdf">presentation</a>
for details (en fran&ccedil;ais).<br>
<br>
<h2>Simulated Events</h2>
<br>
New classes for handling simulated data, converting them into
KaliVeda-format events and storing them in trees, have been added:<br>
&nbsp;&nbsp;&nbsp; <span style="font-style: italic;">KVSimNucleus,
KVSimEvent</span> : base classes for simulated particles and events<br>
&nbsp;&nbsp;&nbsp; <span style="font-style: italic;">KVSimReader</span>
: base class for conversion of simulated data<br>
&nbsp;&nbsp;&nbsp; <span style="font-style: italic;">KVSimReader_HIPSE,
KVSimReader_MMM,
KVSimReader_SMF</span> : dedicated data-conversion
classes<br>
<br>
<h2>analyse_logs</h2>
<br>
Simpler to use version of BQS logs analysis tool. Now it is only
necessary to give the "basename" of the set of parallel batch jobs to
analyse, e.g. in order to analyse all log files in a directory with
names like<br>
<pre>MyAnalysis_132Sn132Sn50_R100.o5698672<br>MyAnalysis_132Sn132Sn50_R101.o5123398<br>MyAnalysis_132Sn132Sn50_R102.o5752948<br>MyAnalysis_132Sn132Sn50_R103.o5695566<br></pre>
etc. etc., it is sufficient to give the common root of all the
filenames,<br>
<pre>analyse_logs MyAnalysis_132Sn132Sn50</pre>
<br>
<h2>Partitions<br>
</h2>
<h3><br>
</h3>
New classes for generating &amp; handling partitions:<br>
<span style="font-style: italic;">&nbsp;&nbsp;&nbsp;&nbsp; - KVBreakUp,
KVPartition, KVPartitionManager, KVPartitionFunction<span
 style="font-style: italic;"></span></span><span
 style="font-style: italic;"><span style="font-style: italic;"></span><br>
<br>
</span>
<h2>Numerical integration</h2>
<br>
<span style="font-style: italic;">KVRungeKutta</span><br>
&nbsp;&nbsp;&nbsp; - Implementation of <span
 style="font-style: italic;">Numerical Recipes</span> 4th order
Runge-Kutta integrator with adaptive step-size control.<br>
<h2><br>
</h2>
<h2>Impact parameter</h2>
<span style="font-style: italic;"><br>
KVImpactParameter<br>
</span>&nbsp;&nbsp;&nbsp; - use distribution of any experimental
observable to establish an impact parameter scale (using the Cavata
method). Any distribution of the observable (e.g. for different event
selections) can be transformed into an impact parameter distribution.
Any 2D histogram of another observable as a function of the impact
parameter-related observable can be used to generate plots of the mean,
r.m.s. fluctuation, skewness, etc., of the observable as a function of
the impact parameter. The value of the impact parameter for any value
of the observable, and vice-versa, can be obtained.<br>
<br>
<h2>Base Classes</h2>
<h3><br>
</h3>
<h3>KVBase</h3>
<h4>New public member KVBase::kIsKaliVedaObject</h4>
We can test the 'KVBase'-ness of any object through a
TObject* base pointer using the new 'KaliVeda' bit,
KVBase::kIsKaliVedaObject:
<pre>TObject *obj = ... // pointer to some object<br>if( obj-&gt;TestBit( KVBase::kIsKaliVedaObject ) ){ // test if object derives from KVBase<br>	...<br>}</pre>
<h4>Access to bazaar revision control data</h4>
Information on the branch name, revision number, id &amp; date can be
obtained from new static member functions:
<table class="func" id="tabfuncpubl" cellspacing="0">
  <tbody>
    <tr class="func">
      <td class="funcret">static <span class="keyword">const</span> <a
 href="http://indra.in2p3.fr/KaliVedaDoc/1.8.0/ListOfTypes.html#Char_t">Char_t</a>*</td>
      <td class="funcname"><a class="funcname"
 href="http://indra.in2p3.fr/KaliVedaDoc/1.8.0/KVBase.html#KVBase:bzrBranchNick">bzrBranchNick</a>()</td>
    </tr>
    <tr class="func">
      <td class="funcret">static <a
 href="http://indra.in2p3.fr/KaliVedaDoc/1.8.0/ListOfTypes.html#Int_t">Int_t</a></td>
      <td class="funcname"><a class="funcname"
 href="http://indra.in2p3.fr/KaliVedaDoc/1.8.0/KVBase.html#KVBase:bzrIsBranchClean">bzrIsBranchClean</a>()</td>
    </tr>
    <tr class="func">
      <td class="funcret">static <span class="keyword">const</span> <a
 href="http://indra.in2p3.fr/KaliVedaDoc/1.8.0/ListOfTypes.html#Char_t">Char_t</a>*</td>
      <td class="funcname"><a class="funcname"
 href="http://indra.in2p3.fr/KaliVedaDoc/1.8.0/KVBase.html#KVBase:bzrRevisionDate">bzrRevisionDate</a>()</td>
    </tr>
    <tr class="func">
      <td class="funcret">static <span class="keyword">const</span> <a
 href="http://indra.in2p3.fr/KaliVedaDoc/1.8.0/ListOfTypes.html#Char_t">Char_t</a>*</td>
      <td class="funcname"><a class="funcname"
 href="http://indra.in2p3.fr/KaliVedaDoc/1.8.0/KVBase.html#KVBase:bzrRevisionId">bzrRevisionId</a>()</td>
    </tr>
    <tr class="func">
      <td class="funcret">static <a
 href="http://indra.in2p3.fr/KaliVedaDoc/1.8.0/ListOfTypes.html#Int_t">Int_t</a></td>
      <td class="funcname"><a class="funcname"
 href="http://indra.in2p3.fr/KaliVedaDoc/1.8.0/KVBase.html#KVBase:bzrRevisionNumber">bzrRevisionNumber</a>()</td>
    </tr>
  </tbody>
</table>
Some infos are displayed when KVBase::InitEnvironment is called at
start-up:<br>
<pre>Info in &lt;KVBase::InitEnvironment&gt;: Initialising KaliVeda environment...<br>Info in &lt;KVBase::InitEnvironment&gt;: Using KaliVeda version 1.8.0 built on 2010-05-26<br>Info in &lt;KVBase::InitEnvironment&gt;: (BZR branch : 1.8 revision#174 (clean=0) date : 2010-05-26 15:12:24 +0200)</pre>
<br>
<h3>New extended collection classes</h3>
<span style="font-style: italic;">KVSeqCollection, KVList, KVHashList,
KVUniqueNameList</span>
<h4><br>
</h4>
KVSeqCollection adds functionality such as
<ul>
  <li>FindObjectByType</li>
  <li>FindObjectByLabel</li>
  <li>GetSublistWithType</li>
</ul>
etc. to the standard ROOT collection classes (these methods were
previously implemented in KVList, an extended TList; now these
extensions can be used with all ROOT collections). The actual
collection class used by KVSeqCollection is embedded and
referenced through a TSeqCollection base pointer. The class of the
embedded object for any given
instance is passed as an argument to the constructor:<br>
<br>
<code>
KVSeqCollection* my_coll = new KVSeqCollection("THashList");
</code><br>
<br>
Any collection class derived from TSeqCollection is valid: this means
all ordered collections, for which the order in which
objects are added is preserved. These lists can also be sorted.<br>
KVList is a new class with all the same functionality as the old
(&lt;v1.8) KVList class. As before, a KVList owns its objects by
default. KVList now inherits from TSeqCollection through
KVSeqCollection, and no longer from TList as before.<br>
KVHashList implements a THashList with added functionality, as well as
enabling automatic rehashing by default (which is not the case for
THashList).<br>
KVUniqueNameList derives from KVHashList, and uses the automatic
rehashing facility in order to provide a list which checks that each
object added has a different name to the objects already in the list,
without becoming unfeasibly slow as the list grows large.<br>
<h4>Cleanups<br>
</h4>
KVSeqCollection greatly simplifies the use of the ROOT cleanup
mechanism in order to keep any list consistent when objects are deleted
outside of the list. We also handle the special case where the objects
also belong to the list (i.e. it would have been the list's
responsability to delete them had they not been deleted by something
else).<br>
<h4>Signals &amp; slots: monitoring list modification</h4>
If SendModifiedSignals(kTRUE) is called, then every time an object is
added to or removed from the list, it will emit
the signal "Modified()". This can be used to monitor any changes to the
state of the list.<br>
<h4>FindObjectBy...</h4>
In addition to the standard TList::FindObject(const Char_t* name) and
TList::FindObject(TObject*) methods, KVSeqCollection adds methods to
find
objects based on several different properties, such as type, label,
number, or class. Note that type, label and number are only defined for
objects derived from KVBase; if the list contains a mixture of TObject-
and KVBase-derived objects, the TObject-derived objects will be ignored
if type, label or number are used to search.<br>
Finally, the very general FindObjectWithMethod method can search for an
object using any valid method.<br>
<h4>Sublists</h4>
The GetSubListWith... methods allow to generate new lists containing a
subset of the objects in the main list, according to their name, label,
type, etc. These sublists do not own their objects (they are supposed
to be owned by the main list), and must be deleted by the user in order
to avoid memory leaks.<br>
<h4>Execute</h4>
The Execute methods can be used to execute a given method with the same
arguments for every object in the list.<br>
<br>
<h3>KVDataBranchHandler</h3>
Utility class allowing to write and read data stored in object member
variables in the branches of a TTree.<br>
<h3><br>
</h3>
<h3>KVClassMonitor</h3>
Simple memory-leak tracking tool. Tracks classes whose instance count
increases over time.<br>
<br>
<h3>KVEventListMaker</h3>
Compute TEventList on trees (???)<br>
<br>
<h3>KVNameValueList, KVValues</h3>
Handle operations on variables (???)<br>
<br>
<h2>Particles &amp; Nuclei</h2>
<h3><br>
</h3>
<h3>Nuclear mass tables<br>
</h3>
KVMassTable is a new abstract base class for nuclear mass tables, of
which <a
 href="http://indra.in2p3.fr/KaliVedaDoc/1.8.0/PACE2MassTable.html">PACE2MassTable</a>
is a specific implementation for the mass table originally used in the
SIMON code.<span style="font-family: monospace;"> </span>Different
mass tables can be implemented using classes derived from <a
 href="http://indra.in2p3.fr/KaliVedaDoc/1.8.0/KVMassTable.html"><span
 style="font-family: monospace;"></span>KVMassTable</a>. The mass table
to be used by KVNucleus is defined by the environment variable<br>
<pre>  <a href="http://indra.in2p3.fr/KaliVedaDoc/1.8.0/KVNucleus.html">KVNucleus</a>.MassTable:        MyMassTable<br></pre>
where 'MyMassTable' must be defined in terms of a <a
 href="http://indra.in2p3.fr/KaliVedaDoc/1.8.0/KVMassTable.html">KVMassTable</a>
plugin:<br>
<pre>+Plugin.<a
 href="http://indra.in2p3.fr/KaliVedaDoc/1.8.0/KVMassTable.html">KVMassTable</a>: MyMassTable  MyMassTable  MyMassTable.cpp+  <span
 class="string">"MyMassTable()"</span></pre>
<br>
<span style="font-style: italic;"><br>
<br>
</span>
</div>
</body>
</html>
